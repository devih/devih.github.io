<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>sqli-lab(5~6详解)</title>
      <link href="2020/10/17/sqli-lab(5-6%E8%AF%A6%E8%A7%A3)/"/>
      <url>2020/10/17/sqli-lab(5-6%E8%AF%A6%E8%A7%A3)/</url>
      
        <content type="html"><![CDATA[<p>**</p><h2 id="Less-5-GET-Double-Injection-Single-Quotes-String-双注入GET单引号字符型注入"><a href="#Less-5-GET-Double-Injection-Single-Quotes-String-双注入GET单引号字符型注入" class="headerlink" title="Less-5 GET - Double Injection - Single Quotes - String (双注入GET单引号字符型注入)"></a>Less-5 GET - Double Injection - Single Quotes - String (双注入GET单引号字符型注入)</h2><p>**</p><p><strong>知识点：1，时间延迟型手工注入；布尔型手工注入；使用concat聚合函数<br>2，payload原理及防御措施<br>3，sqlmap真香，脚本也好使</strong></p><p>**</p><h2 id="0x0a-时间延迟型手工注入"><a href="#0x0a-时间延迟型手工注入" class="headerlink" title="0x0a 时间延迟型手工注入"></a>0x0a 时间延迟型手工注入</h2><p>**</p><p>ps: 什么是时间盲注，时间盲注就是页面不会有回显，没有回显怎么办？这时候我们可以通过sleep（），让他沉睡<br>为什么通过sleep() 可以判断是否存在时间盲注，因为只要执行了，就说明网址存在交互，存在交互就存在漏洞<br>sql注入本质或者条件：<br>1，用户可以控制输入<br>2，拼接了用户输入的数据，并且去成功的执行了</p><p><em>即，如果语句正确就有延迟，加载慢，得等；不对，一下下就好了，可以通过浏览器的刷新提示观察延迟情况</em></p><p><strong>核心语句：?id=1’ and if(报错型payload核心部分,sleep(5),1)–+</strong></p><p><strong>判断有无注入点</strong></p><p><img src="https://img-blog.csdnimg.cn/20201017204549603.png#pic_center" alt="在这里插入图片描述"></p><p>从源码里看到单引号包围查询语句</p><p>判断的时候闭合掉，然后sleep(x), x是几都可以，指在交互过程中，你下的睡眠命令执行时间，通过时间延迟判断盲注</p><p><img src="https://img-blog.csdnimg.cn/20201017204912933.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2dvbmdqaW5nZWdl,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>等待5~7秒左右，没有回显，存在注入点</p><p><strong>判断数据库长度</strong></p><p>使用  <strong>if() 函数</strong></p><p>i<em>f(exp1,exp2,exp3)<br>如果exp1语句正确，那么就会执行exp2，如果不正确，就会执行exp3<br>所以我们第一个exp可以写：length(database())=x<br>exp2:  sleep(5)<br>exp3 :  1</em></p><p>这时候长度x可以用<strong>二分法</strong>（节约时间）</p><p>这时候再代入if这里面</p><p><img src="https://img-blog.csdnimg.cn/20201017205527813.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2dvbmdqaW5nZWdl,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>二分法多试几次，最后判断为8</p><p><img src="https://img-blog.csdnimg.cn/202010172055490.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2dvbmdqaW5nZWdl,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><strong>查库名</strong></p><p>这里还是推荐二分法，不然一个个试太慢了</p><p><img src="https://img-blog.csdnimg.cn/20201017210249705.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2dvbmdqaW5nZWdl,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><img src="https://img-blog.csdnimg.cn/20201017210305524.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2dvbmdqaW5nZWdl,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/20201017210312741.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2dvbmdqaW5nZWdl,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><img src="https://img-blog.csdnimg.cn/20201017210320285.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2dvbmdqaW5nZWdl,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/20201017210326318.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2dvbmdqaW5nZWdl,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>除了这个语句，还可以用<strong>substr和ascii</strong></p><p>?id=1’ and if(ascii(substr(database(),1,1))&gt;=50,sleep(5),1)–+<br>ps:这里比较的是字母的ascii值</p><p><strong>查表名</strong></p><p><img src="https://img-blog.csdnimg.cn/20201017210816430.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2dvbmdqaW5nZWdl,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>这里说一下，可以选择一个个爆破，查出所有的，也可以定向爆破，我这里是定向爆破，即直接写出users表名，在limit里变，最后在limit3，1可以查询出，另一种就limit1,1),1)=’’,二分法试出1的表名，然后2，3，才能有users（所以定向爆破快（sqlmap更快。。。））</p><p><img src="https://img-blog.csdnimg.cn/20201017211225875.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2dvbmdqaW5nZWdl,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><strong>查列名</strong></p><p>同上，不再啰嗦</p><p><img src="https://img-blog.csdnimg.cn/20201017211346162.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2dvbmdqaW5nZWdl,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20201017211402266.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2dvbmdqaW5nZWdl,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><strong>查字段</strong></p><p>二分法</p><p><img src="https://img-blog.csdnimg.cn/20201017211519542.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2dvbmdqaW5nZWdl,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/20201017211546811.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2dvbmdqaW5nZWdl,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>username同理</p><p>注意limit 从0开始。一直试爆破到第一个用户的名字dumb，密码dumb，需要注意的是，mysql对大小写不敏感，所以你不知道是Dumb 还是dumb。</p><p>**</p><h2 id="0x0b-布尔型手工注入"><a href="#0x0b-布尔型手工注入" class="headerlink" title="0x0b 布尔型手工注入"></a>0x0b 布尔型手工注入</h2><p>**</p><p>在布尔型注入中，<strong>正确会回显，错误没有回显</strong></p><p>与上边的时间延迟型比起来，去掉sleep部分</p><p>其他步骤操作差不多</p><pre><code class="python">?id=1&#39; and left((select table_name from information_schema.tables where table_schema=database() limit 1,1),1)=&#39;r&#39; --+</code></pre><pre><code class="python">?id=1&#39; and left((select column_name from information_schema.columns where table_name=&#39;users&#39; limit 4,1),8)=&#39;password&#39; --+</code></pre><p>不再多说，仿照上文编写payload即可</p><p>**</p><h2 id="0x0c-使用concat聚合函数"><a href="#0x0c-使用concat聚合函数" class="headerlink" title="0x0c 使用concat聚合函数"></a>0x0c 使用concat聚合函数</h2><p>**</p><p>使用聚合函数进行双注入查询时，会在错误信息中显示一部分错误信息。比如count函数后面如果使用分组语句就会把查询的一部分以错误的形式显示出来。这样通过回显不就能看见信息了吗</p><p>步骤一样，payload不同，简单贴出，参考对比学习</p><p><img src="https://img-blog.csdnimg.cn/20201017212620798.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2dvbmdqaW5nZWdl,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/20201017212656551.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2dvbmdqaW5nZWdl,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/2020101721270963.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2dvbmdqaW5nZWdl,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/20201017212731879.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2dvbmdqaW5nZWdl,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/2020101721274033.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2dvbmdqaW5nZWdl,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/20201017212751217.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2dvbmdqaW5nZWdl,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>修改limit x,1 可以显示第x个用户的password和username  （‘[’是分隔符），这里是1，3个用户</p><p>**</p><h2 id="0x0d-payload原理及防御"><a href="#0x0d-payload原理及防御" class="headerlink" title="0x0d payload原理及防御"></a>0x0d payload原理及防御</h2><p>**</p><p>1，时间延迟型的payload原理前文提及，就是通过执行命令，造成延迟，判断<br>2，布尔型，页面只返回True和False两种类型页面，count(*)计数   concat()连接字符   floor()重复数据，返回0,1两个值  group by 进行分组 rand(0)避免数据重复造成的错误，透过回显，进行判断<br>3，concat聚合函数，即双查询，例，Select concat((select database())); 真正执行的时候，先从子查询进行。因此执行select database() 这个语句就会把当前的数据库查出来，然后把结果传入到concat函数。双注入查询需要理解四个函数/语句Rand() //随机函数 ，Floor() //取整函数，Count() //汇总函数 ，Group by clause //分组语句，具体并不是很理解，看<a href="http://www.2cto.com/article/201303/192718.html">大佬</a></p><p>4，防御：1），参数化查询是目前防范 SQL注入攻击效果最为明显的技术．它的优势主要表现为：首先，通过参数的 赋值有效过滤掉敏感数值；其次，执行计划的重用性固定了SQL语句的语义，杜绝了重新执行 SQL语句 的语法解析带来的隐患；此外，可以提高查询性能，对于操作数据量较大的Web应用程序显得尤为重要．同 时，参数化查询对数据库平台的支持性非常好，Access、SQL Server、MySQL、Oracle等常用数据库都支 持参数化查询．如果对Web程序和数据库系统安全性能要求较高，参数化查询将是很好的选择．<br>2），存储过程的优势则体现在以下几点：1)减少网络通信量．如果一个存储过程包含了几百条SQL指令， 那么这个存储过程的执行效率要比单独执行上百次的SQL指令高得多；2)执行速度更快．存储过程在创建 的同时就由数据库系统对其进行了优化和解析，而且同样的存储过程多次执行，可以从内存中直接调用， 而不需要重新创建．3)可维护I生高．程序开发人员可在不改动存储过程接口的基础上对数据库进行再开发， 而这些开发不会对Web程序造成影响．但是，存储过程也存在一定的局限，如果存储过程中执行的命令是 拼接字符串，则会存在被注入攻击的隐患．此外，存储过程并不支持所有的数据库平台．<br>3），URL重写技术通过隐藏真实的URL地址而提高Web程序的安全性．其最大的特点在于可以在不改动 Web程序接I21和数据库设计的基础上，利用ISAPI筛选器在IIS Web主机上实现，降低了应用难度，这对 程序开发要求不高的环境显得更为实用．但是，利用ISAPI筛选器实现URL重写对平台有一定的局限性， 只适用于Windows系列操作系统的服务器．</p><p>防御不太懂，<a href="http://qikan.cqvip.com/Qikan/Article/ReadIndex?id=47748139&info=kFHVfbw98IkqosiKHgC9KyjvLo97yghaqL/2oBO9XFk=">大佬论文</a></p><p>5，substr()函数：</p><pre><code>substr()函数从特定位置开始的字符串返回一个给定长度的子字符串substr()函数有三个参数，用法为：substr(str,pos,len)str参数代表待截取的字符串pos参数代表从什么位置开始截取len参数表示字符串截取的长度</code></pre><p>ascii()函数：</p><pre><code> ascii()函数可以输出某个字符的ascii码值，ascii码共127个，此处注意ascii函数处理单个字符，如果是字符串则会处理第一个字符</code></pre><p>**</p><h2 id="0x0e-sqlmap和脚本"><a href="#0x0e-sqlmap和脚本" class="headerlink" title="0x0e sqlmap和脚本"></a>0x0e sqlmap和脚本</h2><p>**</p><p><strong>sqlmap</strong>在盲注这方面比较快，比你一个个试快好多啊。。。人生苦短，快用sqlmap。<br>ps：后续会学习sqlmap的使用，在这里<strong>手工注入，主要是为了了解原理</strong>，了解原理后，在使用工具<strong>burp suite</strong>爆破盲注</p><p><strong>脚本</strong>同理，只有更好的了解原理，才能编写更好的脚本，放个<a href="https://blog.csdn.net/m0_46304840/article/details/104688966">大佬脚本</a>，后续学习使用</p><pre><code class="python">import requestsimport timeheaders = &#123;&quot;user-agent&quot;: &quot;Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 5.1; 360SE)&quot;&#125;chars = &#39;abcdefghigklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789@_.&#39;database = &#39;&#39;global lengthdef get_db():    for l in range(1, 20):        lengthUrl = &#39;http://59.63.200.79:8815/Pass-13/index.php?id=1&quot; and if(length(database())&gt;&#123;0&#125;,1,sleep(3))--+&#39;        lengthUrlFormat = lengthUrl.format(l)        start_time0 = time.time()        rsp0 = requests.get(lengthUrlFormat, headers=headers)        if time.time() - start_time0 &gt; 2.5:            print(&#39;[-]database length：&#39; + str(l))            global length            length = l            break        else:            pass    for i in range(1, length + 1):        for char in chars:            charAscii = ord(char)            url = &#39;http://59.63.200.79:8815/Pass-13/index.php?id=1&quot; and if(ascii(substr(database(),&#123;0&#125;,1))&gt;&#123;1&#125;,1,sleep(3))--+&#39;            urlformat = url.format(i, charAscii)            start_time = time.time()            rsp = requests.get(urlformat, headers=headers)            if time.time() - start_time &gt; 2.5:                global database                database += char                print(&#39;[+]database runing: &#39;+ database + &quot;...&quot;)                break            else:                pass    print(&#39;database:&#39; + database)if __name__==&#39;__main__&#39;:    start = time.time()    get_db()    end = time.time()    t = int(end - start)    print(&quot;The url test time: %ss&quot;%t)</code></pre><p><strong><em>了解漏洞，注入，语句原理后再使用工具</em></strong></p><p>(๑•̀ㅂ•́)و✧(๑•̀ㅂ•́)و✧(๑•̀ㅂ•́)و✧(๑•̀ㅂ•́)و✧</p><p>**</p><h2 id="Less-6-GET-Double-Injection-Double-Quotes-String-双注入GET双引号字符型注入"><a href="#Less-6-GET-Double-Injection-Double-Quotes-String-双注入GET双引号字符型注入" class="headerlink" title="Less-6 GET - Double Injection - Double Quotes - String (双注入GET双引号字符型注入)"></a>Less-6 GET - Double Injection - Double Quotes - String (双注入GET双引号字符型注入)</h2><p>**</p><p>双引号字符型注入，单引号改一下就行</p><p>也是有这几种方法，步骤不多说了，参考上文尝试。</p><p><strong>参考链接：<a href="https://blog.csdn.net/qq_41420747/article/details/81836327">https://blog.csdn.net/qq_41420747/article/details/81836327</a></strong></p><p>2020.10.17  公瑾</p><p> ╭(●｀∀′●)╯╰(●’◡’●)╮ (●’◡’●)ﾉ ヾ(<em>′▽‘</em>)ﾉ( ‘-ωก̀ )( ‘-ωก̀ )( ‘-ωก̀ )( ‘-ωก̀ )</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>sqli-lab(1~4详解)</title>
      <link href="2020/10/09/sqli-lab(1-4%E8%AF%A6%E8%A7%A3)/"/>
      <url>2020/10/09/sqli-lab(1-4%E8%AF%A6%E8%A7%A3)/</url>
      
        <content type="html"><![CDATA[<h2 id="Less-1-GET-Error-based-Single-quotes-String-基于错误的GET单引号字符型注入"><a href="#Less-1-GET-Error-based-Single-quotes-String-基于错误的GET单引号字符型注入" class="headerlink" title="Less-1 GET - Error based - Single quotes - String(基于错误的GET单引号字符型注入)"></a><strong>Less-1 GET - Error based - Single quotes - String(基于错误的GET单引号字符型注入)</strong></h2><pre><code> SQL注入即是指web应用程序对用户输入数据的合法性没有判断或过滤不严，攻击者可以在web应用程序中事先定义好的查询语句的结尾上添加额外的SQL语句，在管理员不知情的情况下实现非法操作，以此来实现欺骗数据库服务器执行非授权的任意查询，从而进一步得到相应的数据信息。</code></pre><p><strong>知识点</strong>：1，判断是数字型还是字符型，单引号还是双引号<br>                    2，union select联合查询注入<br>                    3，payload原理与防御措施</p><h2 id="0X0a"><a href="#0X0a" class="headerlink" title="0X0a"></a><strong>0X0a</strong></h2><pre><code>判断注入点及类型这道题因为是sqli-lab的靶场，所以知道是get型的单引号注入，直接在url栏就可以尝试通常情况下，加个单引号，使id这个参数不能闭合，通过分析返回的报错信息，来进一步判断![在这里插入图片描述](https://img-blog.csdnimg.cn/20201007212113129.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2dvbmdqaW5nZWdl,size_16,color_FFFFFF,t_70#pic_center)**单引号判断‘ 显示数据库错误信息或者页面回显不同(整形,字符串类型判断)** 可以看到，单引号没有闭合，返回了报错信息，显示的就是单引号兄弟萌也可以直接打开源码，通过一步步的比较，进一步学习</code></pre><p><img src="https://img-blog.csdnimg.cn/20201007212337363.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2dvbmdqaW5nZWdl,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br> sql语句如上图，id这个参数周围是单引号<br> <strong>and 1=1 / and 1=2 回显页面不同(整形判断)</strong><br>    <img src="https://img-blog.csdnimg.cn/20201007213333240.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2dvbmdqaW5nZWdl,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20201007213338366.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2dvbmdqaW5nZWdl,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>在数据库中 1=1 和1=2  后面随便输入字符串（相当于1=1和1=2后面的查询语句），发现select 1=”1dasd”时返回1正确，1=”2dasd”时返回0错误，即select在查询时忽略后面的字符串，只让1和后面第一个数字对比，如果相等就是正确，不相等返回错误。</p><h2 id="0x0b"><a href="#0x0b" class="headerlink" title="0x0b"></a><strong>0x0b</strong></h2><pre><code>    **union select联合查询注入**            1，***判断列数***    order by 函数是对MySQL中查询结果按照指定字段名进行排序，除了指定字 段名还可以指定字段的栏位进行排序，第一个查询字段为1，第二个为2，依次 类推。我们可以通过二分法来猜解列数    输入order by 4 --+,页面回显错误，说明不存在第四列</code></pre><p><img src="https://img-blog.csdnimg.cn/20201009111632654.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2dvbmdqaW5nZWdl,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>如此实验2和3，发现3成功，故列数为3</p><p>2，**<em>判断页面回显的列数**</em></p><p><img src="https://img-blog.csdnimg.cn/20201007214147271.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2dvbmdqaW5nZWdl,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述">回显发现2，3列会被显示</p><p>为什么这里得用-1？？为什么2，3被显示了</p><p>因为，程序在展示数据的时候通常只会取结果集的第一行数据，看一下源码，mysql_fetch_array只被调用了一次，而mysql_fetch_array从结果集中取得一行作为关联数组或数字数组或二者兼有，具体看第二个参数是什么。所以这里无论怎么折腾最后只会出来第一行的查询结果。只要让第一行查询的结果是空集，即union左边的select子句查询结果为空，那么union右边的查询结果自然就成为了第一行，打印在网页上了。将id改成-1，使union前面的语句报错，执行后面的，爆出显示位2，3</p><p><strong><em>3，查库名，得表名，爆列名，获字段</em></strong></p><p>group_concat([DISTINCT] 要连接的字段 [Order BY ASC/DESC 排序字段] [Separator ‘分隔符’])<br>说明：通过使用distinct可以排除重复值；如果希望对结果中的值进行排序，可以使用order by子句；separator是一个字符串值，缺省为一个逗号。(具体有点多，请自查，我也不是很懂。。。)</p><p>SCHEMATA表：储存mysql所有数据库的基本信息，包括数据库名，编码类型路径等，show databases的结果取之此表。</p><p>TABLES表：储存mysql中的表信息，（当然也有数据库名这一列，这样才能找到哪个数据库有哪些表嘛）包括这个表是基本表还是系统表，数据库的引擎是什么，表有多少行，创建时间，最后更新时间等。show tables from schemaname的结果取之此表</p><p>COLUMNS表：提供了表中的列信息，（当然也有数据库名和表名称这两列）详细表述了某张表的所有列以及每个列的信息，包括该列是那个表中的第几列，列的数据类型，列的编码类型，列的权限，猎德注释等。是show columns from schemaname.tablename的结果取之此表。</p><p><img src="https://img-blog.csdnimg.cn/20201007215104868.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2dvbmdqaW5nZWdl,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/20201007215435736.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2dvbmdqaW5nZWdl,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/20201007215640830.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2dvbmdqaW5nZWdl,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/20201007215442890.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2dvbmdqaW5nZWdl,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>/<em>注意，查询information_schema中的信息时，使用where语句，那个值不能直接用英文，要用单引号包裹着，当然用其十六进制表示也可以，数值类型的就不用单引号了，这对过滤单引号应该有指导意义。</em>/     （这里并没有过滤，所以没用）</p><h2 id="0x0c-payload原理与防御措施"><a href="#0x0c-payload原理与防御措施" class="headerlink" title="0x0c payload原理与防御措施"></a><strong>0x0c payload原理与防御措施</strong></h2><p><strong>1，</strong>为什么要单引号<br>            原理：加单引号是为了让后台SQL语句执行的时候报错，这样，我们就可以初步判断单引号被放在SQL语句中执行了，执行的语句因为有单引号而出错了，方便浑水摸鱼<br>            防御：1、  将单引号过滤或者替换 – 一般程序都是这样做的    2、将单引号转义 – 所谓转义就是让它成为一个普通的字符，而不具备执行功能，php常用addslashes()函数完成这一功能    3、 将服务器设置为不允许爆错或者爆404 not found</p><p><strong>2，</strong>权限绕过<br>            有俗称的万能语句：SELECT * FROM users WHERE name = ‘’ OR ‘1’=’1’;<br>            即1=1永远为真<br>            如果这些SQL查询放在权限验证的代码中，那么该代码就会爆权限绕过了。<br><strong>3，</strong>多语句执行<br>            最常用的就是union select联合查询注入<br>            UNION 操作符用于合并两个或多个 SELECT 语句的结果集。 请注意，UNION 内部的 SELECT 语句必须拥有相同数量的列。列也必须拥有相似的数据类型。同时，每条 SELECT 语句中的列的顺序必须相同。<br>            比如，SELECT * FROM userinfo WHERE id=1;<strong>DROP TABLE users;</strong><br>            删库跑路。。。</p><p>sql注入的防御与绕过还不是很懂，<a href="https://www.cnblogs.com/milantgh/p/4394467.html">大佬链接</a></p><h2 id="Less-2-GET-Error-based-Intiger-based-基于错误的GET整型注入"><a href="#Less-2-GET-Error-based-Intiger-based-基于错误的GET整型注入" class="headerlink" title="Less-2 GET - Error based - Intiger based (基于错误的GET整型注入)"></a><strong>Less-2 GET - Error based - Intiger based (基于错误的GET整型注入)</strong></h2><p>知识点：1，判断是数字型还是字符型，单引号还是双引号<br>2，union select联合查询注入<br>3，payload原理与防御措施</p><p>**</p><h2 id="0x0a"><a href="#0x0a" class="headerlink" title="0x0a"></a>0x0a</h2><p>**</p><p>这道题与上道题的唯一区别就是这个是整型,即这个题的id参数没有引号，只是数字，这意味着在你绕过的时候可以不需要对后面的引号过滤（如果没有其他干扰的话）</p><p><img src="https://img-blog.csdnimg.cn/20201009112633611.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2dvbmdqaW5nZWdl,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述">这里id=1，虽然回显没报错，但不能确定</p><p><img src="https://img-blog.csdnimg.cn/20201009112709519.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2dvbmdqaW5nZWdl,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>单引号就报错了，有的时候也可能是双引号</p><p><img src="https://img-blog.csdnimg.cn/20201009112743715.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2dvbmdqaW5nZWdl,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>这里后面没有过滤，却成功了，说明这个应该就是整型了</p><p>通过阅读源码，也是很讷到的</p><p><img src="https://img-blog.csdnimg.cn/20201009112936707.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2dvbmdqaW5nZWdl,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>id这个参数只是数字，没有一些过滤，所以确定是整型</p><p>**</p><h2 id="0x0b-1"><a href="#0x0b-1" class="headerlink" title="0x0b"></a>0x0b</h2><p>**</p><p>union select联合查询注入也是一样，区别也是id后无单引号，原因就不再说了，前边有</p><p>稍微演示前几步，知道具体区别</p><p><img src="https://img-blog.csdnimg.cn/20201009113409289.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2dvbmdqaW5nZWdl,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20201009113415152.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2dvbmdqaW5nZWdl,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>很清楚的知道id=1，后面没有引号</p><p><img src="https://img-blog.csdnimg.cn/20201009113459371.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2dvbmdqaW5nZWdl,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>通过这幅图与上一幅图比较，可以看见当整型数据无其他干扰时，注释符也可以省略，因为不需要注释掉后边的引号</p><p>后面步骤一样，不再啰嗦</p><p>**</p><h2 id="0x0c"><a href="#0x0c" class="headerlink" title="0x0c"></a>0x0c</h2><p>**</p><p>payload的原理与防御措施，还有前边省略的几步，都在我写的less-1中，有详细的说明</p><p>这里也对前边做点补充</p><p><strong>CONCAT（）函数</strong><br>CONCAT（）函数用于将多个字符串连接成一个字符串。<br>使用数据表Info作为示例，其中SELECT id,name FROM info LIMIT 1;的返回结果为<br>+—-+——–+<br>| id | name |<br>+—-+——–+<br>| 1 | BioCyc |<br>+—-+——–+<br>语法及使用特点：<br>CONCAT(str1,str2,…)<br>返回结果为连接参数产生的字符串。如有任何一个参数为NULL ，则返回值为 NULL。可以有一个或多个参数。</p><p><strong>GROUP_CONCAT（）函数</strong><br>GROUP_CONCAT函数返回一个字符串结果，该结果由分组中的值连接组合而成。 </p><p>使用语法及特点：<br>GROUP_CONCAT([DISTINCT] expr [,expr …]<br>[ORDER BY {unsigned_integer | col_name | formula} [ASC | DESC] [,col …]]<br>[SEPARATOR str_val])<br>在 MySQL 中，你可以得到表达式结合体的连结值。通过使用 DISTINCT 可以排除重复值。如果希望对结果中的值进行排序，可以使用 ORDER BY 子句。<br>SEPARATOR 是一个字符串值，它被用于插入到结果值中。缺省为一个逗号 (“,”)，可以通过指定 SEPARATOR “” 完全地移除这个分隔符。 </p><p>通常情况下，这两个组合来用，对于sql注入，还是挺方便的</p><p>ps：感觉自己会的都只是浅层表面的，内在也不懂，具体逻辑，原理说不太上来</p><p>还请各位大佬评论区留言指教，非常感谢<del>(≥▽≤)/</del></p><h2 id="Less-3-GET-Error-based-Single-quotes-with-twist-string-基于错误的GET单引号变形字符型注入"><a href="#Less-3-GET-Error-based-Single-quotes-with-twist-string-基于错误的GET单引号变形字符型注入" class="headerlink" title="Less-3 GET - Error based - Single quotes with twist string (基于错误的GET单引号变形字符型注入)"></a><strong>Less-3 GET - Error based - Single quotes with twist string (基于错误的GET单引号变形字符型注入)</strong></h2><p>知识点：1，单引号字符变形，如:(‘’)<br>              2，union select联合查询注入<br>              3，payload原理及防御</p><p>**</p><h2 id="0x0a-1"><a href="#0x0a-1" class="headerlink" title="0x0a"></a>0x0a</h2><p>**</p><p>这几个都是类似的，单引号看一下</p><p><img src="https://img-blog.csdnimg.cn/202010091240468.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2dvbmdqaW5nZWdl,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>通过回显，看到有括号，推测输入的内容存放到一对单引号加圆括号中了，形如select … from … where id=(‘1’) …</p><p><img src="https://img-blog.csdnimg.cn/20201009124227339.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2dvbmdqaW5nZWdl,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>看下源码，能更了解sql注入绕过</p><p><img src="https://img-blog.csdnimg.cn/20201009124310104.png#pic_center" alt="在这里插入图片描述"></p><p>**</p><h2 id="0x0b-2"><a href="#0x0b-2" class="headerlink" title="0x0b"></a>0x0b</h2><p>**</p><p>这里与前文一样，也是看下区别就行，具体payload仿照less-1</p><p><img src="https://img-blog.csdnimg.cn/20201009125140384.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2dvbmdqaW5nZWdl,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/20201009125144307.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2dvbmdqaW5nZWdl,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>**</p><h2 id="0x0c-1"><a href="#0x0c-1" class="headerlink" title="0x0c"></a>0x0c</h2><p>**</p><p>这里与前面不一样的就是过滤id参数，（‘’）这种过滤，通过报错回显，可以进一步了解</p><p>这时如果设置成不允许服务器爆错，他不就抓虾，得盲注了，盲注具体后边题详细说</p><p>union select联合查询注入也是一样，拼接语句，多语句执行绕过</p><p>这几篇一起学习，相似地方很多</p><h2 id="Less-4-GET-Error-based-Double-Quotes-String-（基于错误的GET双引号字符型注入）"><a href="#Less-4-GET-Error-based-Double-Quotes-String-（基于错误的GET双引号字符型注入）" class="headerlink" title="Less-4 GET - Error based - Double Quotes - String （基于错误的GET双引号字符型注入）"></a><strong>Less-4 GET - Error based - Double Quotes - String （基于错误的GET双引号字符型注入）</strong></h2><p>知识点：1，双引号字符型的判断</p><p>**</p><h2 id="0x0a-2"><a href="#0x0a-2" class="headerlink" title="0x0a"></a>0x0a</h2><p>**</p><p>输入单引号，页面无任何变化，这时候就得考虑双引号了</p><p><img src="https://img-blog.csdnimg.cn/20201009130851271.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2dvbmdqaW5nZWdl,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>输入双引号，页面报错</p><p><img src="https://img-blog.csdnimg.cn/20201009130935760.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2dvbmdqaW5nZWdl,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>根据报错信息判断出输入的内容被放到一对双引号和圆括号中</p><p>打开源码，一探究竟</p><p><img src="https://img-blog.csdnimg.cn/20201009131014112.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2dvbmdqaW5nZWdl,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>第一行将输入的id值再加一对双引号</p><p>第二行将id又加了一对括号</p><p>两次没有放在一块，代码审计得认真</p><p>不过也可以理解为select … from … where id=(”1”) …，这样其实一样</p><p>验证看一下</p><p><img src="https://img-blog.csdnimg.cn/20201009131336340.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2dvbmdqaW5nZWdl,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><p>**</p><h2 id="1-4总结"><a href="#1-4总结" class="headerlink" title="1-4总结"></a>1-4总结</h2><p>**</p><p>都是基于错误的GET型一次注入，区别只是字符型或整型，单引号还是双引号，有无括号变形</p><p>payload原理和防御措施也是一样，写在前边了，详情见<strong>less-1末尾</strong>与<strong>less-2末尾</strong></p><p>这几个题放一块，方便学习与理解，参照源码，互相比对</p><p>理解错误之处还望不吝赐教,感谢大佬／人◕ ‿‿ ◕人＼</p><p>2020.10.9   公瑾</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="2020/10/06/hello-world/"/>
      <url>2020/10/06/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre><code class="bash">$ hexo new &quot;My New Post&quot;</code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre><code class="bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre><code class="bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre><code class="bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
